#!/usr/bin/perl

# version 0.1.0

# NOTE: This is one of my first perl script. I am a very beginer in perl, so
# this file is quite hackish...
# For questions you can contact me at peter.csaszar@blumsoft.eu

# This script will process the concatenated collection of all .bcovdump files
# generated by running all the test applications. The goal is to generate a
# summarized .bcovdump.res which has all lines marked as run which was covered
# by any of the tests.


$merge_input_file = ".bcovdump";
$merge_result_file = ".bcovdump.res";


# Lets have an array for each source file to inspect the coverage of.
@sources=(
	'regionmodel.cpp',
	'businesslogic.cpp',
	'widgetlist.cpp',
	'regionview.cpp',
	'mainview.cpp',
	'brief.cpp',
	'applet.cpp');

# Super global :(
$srcpath = "none";


# This function will be called for each source file we want to collect
# coverage information of.
sub merge ($)
{
	# Some initialization. Just to be sure;
	my ($sourcefile) = @_;
	@a_lineno = ();
	@a_instr = ();
	@a_exec_instr = ();
	$current_source = "none";
	$full_source_name = "none";

	# Lets go through the input data...
	foreach (@input) {
		chomp;
		$line = $_;
		# There are coverage informations of many files. We want to
		# use informations belonging to the file this function is
		# called for.
		# For all the other sections we use the name 'none'.
		if ($line =~ /file */){
			$current_source = "none";
			if ($line =~ "src\/$sourcefile") {
				$current_source = $line;
				$full_source_name = $line;
				if($srcpath eq "none"){
					($srcpath) = ($full_source_name =~ /^file (.*)\/.*\.cpp$/);
				}
			}
		}
		# If this is a wanted line with numbers in a wanted section
		if ($current_source =~ "cpp" && $line =~ /^[0-9 ]*$/){
			# Parse the three number
			($lineno, $instr, $exec_instr) =
			($line =~ /^([0-9]*) ([0-9]*) ([0-9]*)$/);

#			print "$lineno $instr $exec_instr\n";
			# Lets find the best coverage result of each line
			if($a_lineno[$lineno] == 0 || # All line informations should be copied at least once
				$a_exec_instr[$lineno] < $exec_instr) # update if better coverage found
			{
				$a_lineno[$lineno] = $lineno;
				$a_exec_instr[$lineno] = $exec_instr;
				$a_instr[$lineno] = $instr;
			}
		}
	}

	# Write the summary collected into array into the result file.
	# Only if there is an array to write.
	if ($full_source_name =~ "cpp"){
		open(OUT, ">>$merge_result_file");
		print OUT "\n$full_source_name\n";
		foreach	(@a_lineno) {
			if(0 < $_){#dont produce empty lines
				$e = $a_exec_instr[$_];
				$i = $a_instr[$_];
				print OUT "$_ $i $e\n";
			}
		}
		close(OUT);
	} else {
		# Even if bcov have no information about, we need all files
		# in the statistics.
		open(OUT, ">>$merge_result_file");
		print OUT "\nfile $srcpath/$sourcefile\n";
#		print OUT "1 1 0\n";
		close(OUT);
	}
}

# This function will append the summary of the results to report.txt file
sub summarize ($)
{
	# Some initialization. Just to be sure;
	my ($reportfile) = @_;
	$s_linecount = 0;
	$s_coveredcount = 0;
	$s_uncoveredcount = 0;
	$linecount = 0;
	$coveredcount = 0;
	$uncoveredcount = 0;
	$current_file = "none";
	
	# Write header line.
	open(OUT, ">>$reportfile");
	printf OUT "%-10s%-10s%-10s%-10s%-20s\n",
		"Lines", "Covered", "Uncovered", "Percent", "Source file";

	# Lets go through the input data...
	foreach (@input) {
		chomp;
		$line = $_;
		if ($line =~ /file */){
			# Before starting to count new file, output the previous;
			if($current_file ne "none"){
				if(0 < $linecount){
					$percent = 100*$coveredcount/$linecount;
				} else {
					$percent = 0;
				}
				printf OUT " %-9s %-9s %-9s %-3.0f%%      %-19s\n",
					$linecount, $coveredcount, $uncoveredcount,
					$percent, $current_file;
			}
			($current_file) = ($line =~ /^.*src\/(.*)$/);
			$linecount = 0;
			$coveredcount = 0;
			$uncoveredcount = 0;
		} elsif ($line =~ /^[0-9 ]*$/){
			# Parse the three number
			($lineno, $instr, $exec_instr) = ($line =~ /^([0-9]*) ([0-9]*) ([0-9]*)$/);

			if($lineno != 0){ # Forget empty lines (having no linenumber info)
				$linecount++;
				$s_linecount++;
				if (0 < $exec_instr) {
					$coveredcount++;
					$s_coveredcount++;
				} else {
					$uncoveredcount++;
					$s_uncoveredcount++;
				}
			}
		}
	}

	# Write the last file's coverage.
	if($current_file ne "none"){
		if(0 < $linecount){
			$percent = 100*$coveredcount/$linecount;
		} else {
			$percent = 0;
		}
		printf OUT " %-9s %-9s %-9s %-3.0f%%      %-19s\n",
			$linecount, $coveredcount, $uncoveredcount,
			$percent, $current_file;
	}

	printf OUT " %-9s %-9s %-9s %-3.0f%%      %-19s\n",
		$s_linecount, $s_coveredcount, $s_uncoveredcount,
		100*$s_coveredcount/$s_linecount, "summary";
	close(OUT);
}


#
# Here comes the main part
#

# The input file should be provided by makefiles. Actualy this one is expected to
# be a concatenation of all the .bcovdump files provided by each of the tests.
open(IN, $merge_input_file);

# This will be the report file which summarizes all the coverages.
open(OUT, ">$merge_result_file");

# Lets make the header:
# Get the line with date. It should be the third one.
$dateline=<IN>;
$dateline=<IN>;
$dateline=<IN>;
print OUT "command N/A\nargs\n$dateline";
close(OUT);

# Get the whole input file into an aray for later reuse.
@input=<IN>;
close(IN);

# Make the summary for each of the source files...
foreach (@sources) {
	merge($_);
}

#Lets get the content of the merged file into @input
open(IN, "$merge_result_file");
@input=<IN>;
close(IN);

summarize("report.txt");



